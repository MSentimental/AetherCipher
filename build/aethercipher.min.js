/*!
 * AetherCipher v1.1.5
 * 
 * [AetherCipher - Public]{@link https://cdn.jsdelivr.net/gh/msentimental/AetherCipher@latest/build/aethercipher.min.js}
 *
 * @version 1.1.5
 * @author msentimental [lijinhan2025@gmail.com]
 * @copyright Strike Bot Inc. 2026
 * @license See full license at https://github.com/MSentimental/AetherCipher/blob/main/LICENSE.md
 * 
 * Includes:
 *   - AetherCipher: Reversible encryption (Do not use directly in frontend unless the user is inputting their own master key)
 *   - AetherHash: One-way hashing (high speed alternative: AetherWarp)
 * 
 * [Usage examples]:
 *
 * <script>
 *   // Cipher initialization
 *   const cipher = new AetherCipher('user-key');
 *   const hasher = new AetherHash();
 *   
 *   // Encrypt something
 *   const secret = cipher.encrypt('Hello World!');
 *   console.log('Encrypted:', secret);
 *  
 *   // Hash something
 *   const hash = hasher.hash256('Hello World!');
 *   console.log('Hashed:', hash);
 * <\/script>
 */
class AetherHash{constructor(){this.blockSize=64,this.rounds=80,this.outputSize=64,this._initHashValues()}_initHashValues(){this.h=new Uint32Array(16),this.h[0]=1779033703,this.h[1]=3144134277,this.h[2]=1013904242,this.h[3]=2773480762,this.h[4]=1359893119,this.h[5]=2600822924,this.h[6]=528734635,this.h[7]=1541459225,this.h[8]=-197222434,this.h[9]=626054972,this.h[10]=-1571190069,this.h[11]=997756035,this.h[12]=-818336826,this.h[13]=87167285,this.h[14]=-2118868974,this.h[15]=-975719264}_rotateRight(t,e){return t>>>e|t<<32-e}_rotateLeft(t,e){return t<<e|t>>>32-e}_sigma0(t){return this._rotateRight(t,7)^this._rotateRight(t,18)^t>>>3}_sigma1(t){return this._rotateRight(t,17)^this._rotateRight(t,19)^t>>>10}_pad(t){let e=(new TextEncoder).encode(t),r=8*e.length,h=new Uint8Array(64*((r+8+64)/512+1));h.set(e),h[e.length]=128;for(let t=0;t<8;t++)h[h.length-8+t]=r>>>56-8*t&255;return h}_compress(t){let e=new Uint32Array(80);for(let r=0;r<16;r++)e[r]=t[4*r]<<24|t[4*r+1]<<16|t[4*r+2]<<8|t[4*r+3];for(let t=16;t<80;t++)e[t]=this._sigma1(e[t-2])+e[t-7]+this._sigma0(e[t-15])+e[t-16]>>>0;let r=this.h[0],h=this.h[1],i=this.h[2],s=this.h[3],n=this.h[4],o=this.h[5],l=this.h[6],a=this.h[7],f=this.h[8],u=this.h[9],g=this.h[10],y=this.h[11],p=this.h[12],c=this.h[13],_=this.h[14],d=this.h[15];for(let t=0;t<80;t++){let w=(a+this._rotateRight(n,14)^this._rotateRight(n,18)^this._rotateRight(n,41)+(l^n&(o^l))+e[t]+t)>>>0,A=(this._rotateRight(r,28)^this._rotateRight(r,34)^this._rotateRight(r,39)+(r&h|i&(r|h)))>>>0;d=_,_=c,c=p,p=y,y=g,g=u,u=f,f=a,a=l,l=o,o=n,n=s+w>>>0,s=i,i=h,h=r,r=w+A>>>0}this.h[0]=this.h[0]+r>>>0,this.h[1]=this.h[1]+h>>>0,this.h[2]=this.h[2]+i>>>0,this.h[3]=this.h[3]+s>>>0,this.h[4]=this.h[4]+n>>>0,this.h[5]=this.h[5]+o>>>0,this.h[6]=this.h[6]+l>>>0,this.h[7]=this.h[7]+a>>>0,this.h[8]=this.h[8]+f>>>0,this.h[9]=this.h[9]+u>>>0,this.h[10]=this.h[10]+g>>>0,this.h[11]=this.h[11]+y>>>0,this.h[12]=this.h[12]+p>>>0,this.h[13]=this.h[13]+c>>>0,this.h[14]=this.h[14]+_>>>0,this.h[15]=this.h[15]+d>>>0}hash(t){if(!t||"string"!=typeof t)throw new Error("AetherHash: Input must be a non-empty string");this._initHashValues();let e=this._pad(t);for(let t=0;t<e.length;t+=64)this._compress(e.slice(t,t+64));let r="";for(let t=0;t<16;t++)r+=this.h[t].toString(16).padStart(8,"0");return r.toLowerCase()}hash256(t){return this.hash(t).substring(0,64)}hash512(t){return this.hash(t)}hmac(t,e){let r=128,h=(new TextEncoder).encode(t);h.length>r&&(h=(new TextEncoder).encode(this.hash(t)));let i=new Uint8Array(r),s=new Uint8Array(r);for(let t=0;t<r;t++)i[t]=54,s[t]=92;for(let t=0;t<h.length;t++)i[t]^=h[t],s[t]^=h[t];let n=Array.from(i).map(t=>t.toString(16).padStart(2,"0")).join(""),o=Array.from(s).map(t=>t.toString(16).padStart(2,"0")).join(""),l=this.hash(n+this._strToHex(e));return this.hash(o+l)}_strToHex(t){return Array.from((new TextEncoder).encode(t)).map(t=>t.toString(16).padStart(2,"0")).join("")}}class AetherCipher{constructor(t){if(!t||"string"!=typeof t)throw new Error("AetherCipher: Key must be a non-empty string");this.blockSize=16,this.halfSize=8,this.rounds=32,this.masterKey=this._hashTo256(t),this.hasher=new AetherHash,this._initKeySchedule()}_hashTo256(t){const e=String(t);let r=new Uint32Array(8);r[0]=1779033703,r[1]=3144134277,r[2]=1013904242,r[3]=2773480762,r[4]=1359893119,r[5]=2600822924,r[6]=528734635,r[7]=1541459225;for(let t=0;t<e.length;t++){let h=e.charCodeAt(t);for(let t=0;t<8;t++)r[t]^=h<<3*t|h>>>5-t,r[t]=2654435769*r[t]>>>0,r[t]^=r[t+3&7]^r[t+7&7]}let h=new Uint8Array(32);for(let t=0;t<8;t++)h[4*t]=r[t]>>24&255,h[4*t+1]=r[t]>>16&255,h[4*t+2]=r[t]>>8&255,h[4*t+3]=255&r[t];for(let t=0;t<100;t++){for(let t=0;t<8;t++)r[t]=2654435769*r[t]>>>0^r[t+3&7];let t=new Uint8Array(32);for(let e=0;e<8;e++)t[4*e]=r[e]>>24&255,t[4*e+1]=r[e]>>16&255,t[4*e+2]=r[e]>>8&255,t[4*e+3]=255&r[e];for(let e=0;e<32;e++)h[e]^=t[e]}return h}_initKeySchedule(){let t=0;for(let e=0;e<32;e++)t^=this.masterKey[e]<<e%4*8,t=2654435769*t>>>0;let e=t,r=2654435769^t,h=2246822507^t,i=3266489909^t;const s=()=>{let t=e^e<<11;return e=r,r=h,h=i,i=i^i>>>19^t^t>>>8,i>>>0};let n=new Uint8Array(this.rounds*this.halfSize);for(let t=0;t<n.length;t++)n[t]=255&s(),n[t]^=this.masterKey[t%32],n[t]^=31*t&255;for(let t=0;t<3;t++)for(let e=0;e<32;e++){let r=(e+7*t)%n.length;n[r]^=this._rotl(this.masterKey[e],3*t),n[n.length-1-r]^=this._rotr(this.masterKey[e],5*t)}this.roundKeys=[];for(let t=0;t<this.rounds;t++)this.roundKeys.push(n.slice(t*this.halfSize,(t+1)*this.halfSize));this.sboxes=[];const o=[283,285,299,301,313,319,333,351,355,357,361,369,375,379,391,395,397,415,419,425,433,445,451,463,471,477,487,499,501,505];for(let t=0;t<16;t++){let e=0;for(let r=0;r<32;r++)e^=this.masterKey[r]<<(r+3*t)%4*8,e=2654435769*e>>>0;let r=o[(e>>>24)%30],h=this._generateAffineMatrix(286331153^e),i=e>>>16&255,s=this._generateAffineMatrix(572662306^e),n=e>>>8&255,l=new Uint8Array(256),a=new Uint8Array(256);for(let t=0;t<256;t++){let e=this._applyAffine(t,h,i),o=this._gf256Inv(e,r),f=this._applyAffine(o,s,n);l[t]=f,a[f]=t}let f=!0;for(let t=0;t<256;t++)if(l[a[t]]!==t){f=!1;break}if(!f){console.warn("Sbox",t,"had issue, using fallback");for(let t=0;t<256;t++){let e=this._gf256Inv(t,283);l[t]=e}}this.sboxes.push(l)}this.invSboxes=[];for(let t=0;t<16;t++){let e=new Uint8Array(256);for(let r=0;r<256;r++)e[this.sboxes[t][r]]=r;this.invSboxes.push(e)}}_rotl(t,e){return t<<e|t>>>32-e}_rotr(t,e){return t>>>e|t<<32-e}_popcount(t){return t=(t=(858993459&(t-=t>>1&1431655765))+(t>>2&858993459))+(t>>4)&252645135,t+=t>>8,63&(t+=t>>16)}_gf256Mult(t,e,r){let h=0;for(;t&&e;)1&e&&(h^=t),e>>=1,256&(t<<=1)&&(t^=r);return 255&h}_gf256Pow(t,e,r){let h=1,i=t;for(;e>0;)1&e&&(h=this._gf256Mult(h,i,r)),i=this._gf256Mult(i,i,r),e>>=1;return h}_gf256Inv(t,e){return 0===t?0:this._gf256Pow(t,254,e)}_generateAffineMatrix(t){let e=t,r=2654435769^t,h=2246822507^t;const i=()=>(e^=e<<13,e^=e>>>17,e^=e<<5,r^=r<<3,r^=r>>>19,r^=r<<7,h^=h<<11,h^=h>>>13,h^=h<<17,e+r+h>>>0);let s=[1,2,4,8,16,32,64,128];for(let t=0;t<32;t++){let t=i()%8,e=i()%8;t!==e&&(s[t]^=s[e])}for(let t=7;t>0;t--){let e=i()%(t+1);[s[t],s[e]]=[s[e],s[t]]}return s}_gf256MatrixDet(t){let e=t.slice(),r=0;for(let t=0;t<8;t++){let h=-1;for(let i=r;i<8;i++)if(e[i]>>t&1){h=i;break}if(-1!==h){[e[r],e[h]]=[e[h],e[r]];for(let h=r+1;h<8;h++)e[h]>>t&1&&(e[h]^=e[r]);r++}}return 8===r?1:0}_applyAffine(t,e,r){let h=0;for(let r=0;r<8;r++)t>>r&1&&(h^=e[r]);return h^r}_makePermutation(t){let e=new Array(256).fill(!1);for(let r=0;r<256;r++){if(e[t[r]])for(let h=0;h<256;h++)if(!e[h]){t[r]=h;break}e[t[r]]=!0}let r=0;for(let e=1;e<256;e++){let h=new Array(256).fill(0);for(let r=0;r<256;r++)h[t[r]^t[r^e]]++;let i=Math.max(...h);i>r&&(r=i)}}_chaoticRng(t){return function(){return(16777215&(t=1664525*t+1013904223>>>0))/16777216}}_F(t,e){let r=new Uint8Array(t);for(let t=0;t<8;t++)r[t]^=this.roundKeys[e][t];for(let t=0;t<8;t++){let h=(t+e)%16;r[t]=this.sboxes[h][r[t]]}let h=new Uint8Array(8);for(let t=0;t<8;t++)h[(t+e+Math.floor(8*Math.sin(r[t])))%8]=r[t];return h}encryptBlock(t){let e=t.slice(0,8),r=t.slice(8,16);for(let t=0;t<this.rounds;t++){let h=new Uint8Array(8);for(let i=0;i<8;i++)h[i]=e[i]^this._F(r,t)[i];e=r,r=h}let h=new Uint8Array(16);return h.set(e,0),h.set(r,8),h}decryptBlock(t){let e=t.slice(0,8),r=t.slice(8,16);for(let t=this.rounds-1;t>=0;t--){let h=new Uint8Array(8),i=this._F(e,t);for(let t=0;t<8;t++)h[t]=r[t]^i[t];r=e,e=h}let h=new Uint8Array(16);return h.set(e,0),h.set(r,8),h}_pad(t){let e=this.blockSize-t.length%this.blockSize,r=new Uint8Array(t.length+e);r.set(t);for(let h=t.length;h<r.length;h++)r[h]=e;return r}_unpad(t){let e=t[t.length-1];if(e<1||e>this.blockSize)throw new Error("AetherCipher: Invalid padding - wrong key or corrupted data");return t.slice(0,t.length-e)}_generateIv(){let t=new Uint8Array(16);for(let e=0;e<16;e++)t[e]=Math.floor(256*Math.random());return t}_authTag(t,e){let r=this.hasher.hash256(this._bytesToHex(t)+e);return this._hexToBytes(r).slice(0,8)}encrypt(t){if(!t||"string"!=typeof t)throw new Error("AetherCipher: Plaintext must be a non-empty string");let e=(new TextEncoder).encode(t),r=this._pad(e),h=this._generateIv(),i=[],s=h;for(let t=0;t<r.length;t+=16){let e=r.slice(t,t+16);for(let t=0;t<16;t++)e[t]^=s[t];let h=this.encryptBlock(e);i.push(h),s=h}let n=new Uint8Array(h.length+r.length);n.set(h);let o=h.length;for(let t of i)n.set(t,o),o+=16;let l=this._bytesToHex(n);return l+this.hasher.hash256(l+this._bytesToHex(this.masterKey)).substring(0,16)}decrypt(t){if(!t||"string"!=typeof t)throw new Error("AetherCipher: Ciphertext must be a hex string");let e=this._hexToBytes(t);if(e.length<32)throw new Error("AetherCipher: Ciphertext too short");let r=this._bytesToHex(e.slice(0,e.length-8)),h=this._bytesToHex(e.slice(e.length-8));if(this.hasher.hash256(r+this._bytesToHex(this.masterKey)).substring(0,16)!==h)throw new Error("AetherCipher: Authentication failed - wrong key or corrupted data");let i=e.slice(0,16),s=e.slice(16,e.length-8),n=[];for(let t=0;t<s.length;t+=16)n.push(s.slice(t,t+16));let o=[],l=i;for(let t of n){let e=this.decryptBlock(t);for(let t=0;t<16;t++)e[t]^=l[t];o.push(e),l=t}let a=new Uint8Array(16*o.length),f=0;for(let t of o)a.set(t,f),f+=16;let u=this._unpad(a);return(new TextDecoder).decode(u)}_bytesToHex(t){return Array.from(t).map(t=>t.toString(16).padStart(2,"0")).join("")}_hexToBytes(t){if(!/^[0-9a-fA-F]+$/.test(t))throw new Error("AetherCipher: Invalid hex string");let e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substr(r,2),16);return e}testVectors(){const t=[{key:"key1",plain:"Hello World!"},{key:"ðŸŒŸðŸ”¥",plain:"Creative unicode âœ“"},{key:"longkey".repeat(10),plain:"A".repeat(300)}];let e=[];for(let r of t){let t=new AetherCipher(r.key),h=t.encrypt(r.plain),i=t.decrypt(h)===r.plain;e.push({key:r.key.substring(0,10)+"â€¦",plain:r.plain.substring(0,20)+"â€¦",pass:i})}return e}avalancheTest(){let t=0,e=[];for(let r=0;r<20;r++){const r=Math.random().toString(36).substring(2)+Math.random().toString(36).substring(2);let h=Math.floor(Math.random()*r.length),i=r.substring(0,h)+String.fromCharCode(1^r.charCodeAt(h))+r.substring(h+1),s=this.encrypt(r),n=this.encrypt(i),o=this._hexToBytes(s),l=this._hexToBytes(n),a=0;for(let t=0;t<o.length;t++){let e=o[t]^l[t];for(;e;)a+=1&e,e>>=1}let f=a/(8*o.length)*100;e.push(f),t+=f}let r=t/20,h=Math.min(...e),i=Math.max(...e);return console.log(`avalanche: avg=${r.toFixed(2)}% min=${h.toFixed(2)}% max=${i.toFixed(2)}%`),r}}"undefined"!=typeof window&&(window.AetherCipher=AetherCipher,window.AetherHash=AetherHash),"undefined"!=typeof module&&module.exports&&(module.exports={AetherCipher:AetherCipher,AetherHash:AetherHash});
