/*!
 * AetherCipher v1.2.2
 * 
 * [AetherCipher - Public]{@link https://cdn.jsdelivr.net/gh/msentimental/AetherCipher@latest/build/aethercipher.min.js}
 *
 * @version 1.2.2
 * @author msentimental [lijinhan2025@gmail.com]
 * @copyright Strike Bot Inc. 2026
 * @license See full license at https://github.com/MSentimental/AetherCipher/blob/main/LICENSE.md
 * 
 * Includes:
 *   - AetherCipher: Reversible encryption (Do not use directly in frontend unless the user is inputting their own master key)
 *   - AetherHash: One-way hashing (high speed alternative: AetherWarp)
 * 
 * [Usage examples]:
 *
 * <script>
 *   // Cipher initialization
 *   const cipher = new AetherCipher('user-key');
 *   const hasher = new AetherHash();
 *   
 *   // Encrypt something
 *   const secret = cipher.encrypt('Hello World!');
 *   console.log('Encrypted:', secret);
 *  
 *   // Hash something
 *   const hash = hasher.hash256('Hello World!');
 *   console.log('Hashed:', hash);
 * <\/script>
 */

class AetherHash{constructor(){this.blockSize=64,this.rounds=80,this.outputSize=64,this._initHashValues()}_initHashValues(){this.h=new Uint32Array(16),this.h[0]=1779033703,this.h[1]=3144134277,this.h[2]=1013904242,this.h[3]=2773480762,this.h[4]=1359893119,this.h[5]=2600822924,this.h[6]=528734635,this.h[7]=1541459225,this.h[8]=-197222434,this.h[9]=626054972,this.h[10]=-1571190069,this.h[11]=997756035,this.h[12]=-818336826,this.h[13]=87167285,this.h[14]=-2118868974,this.h[15]=-975719264}_rotateRight(t,e){return t>>>e|t<<32-e}_rotateLeft(t,e){return t<<e|t>>>32-e}_sigma0(t){return this._rotateRight(t,7)^this._rotateRight(t,18)^t>>>3}_sigma1(t){return this._rotateRight(t,17)^this._rotateRight(t,19)^t>>>10}_pad(t){let e=(new TextEncoder).encode(t),h=8*e.length,r=new Uint8Array(64*((h+8+64)/512+1));r.set(e),r[e.length]=128;for(let t=0;t<8;t++)r[r.length-8+t]=h>>>56-8*t&255;return r}_compress(t){let e=new Uint32Array(80);for(let h=0;h<16;h++)e[h]=t[4*h]<<24|t[4*h+1]<<16|t[4*h+2]<<8|t[4*h+3];for(let t=16;t<80;t++)e[t]=this._sigma1(e[t-2])+e[t-7]+this._sigma0(e[t-15])+e[t-16]>>>0;let h=this.h[0],r=this.h[1],i=this.h[2],s=this.h[3],l=this.h[4],n=this.h[5],o=this.h[6],f=this.h[7],a=this.h[8],u=this.h[9],g=this.h[10],_=this.h[11],y=this.h[12],p=this.h[13],d=this.h[14],c=this.h[15];for(let t=0;t<80;t++){let M=(f+this._rotateRight(l,14)^this._rotateRight(l,18)^this._rotateRight(l,41)+(o^l&(n^o))+e[t]+t)>>>0,A=(this._rotateRight(h,28)^this._rotateRight(h,34)^this._rotateRight(h,39)+(h&r|i&(h|r)))>>>0;c=d,d=p,p=y,y=_,_=g,g=u,u=a,a=f,f=o,o=n,n=l,l=s+M>>>0,s=i,i=r,r=h,h=M+A>>>0}this.h[0]=this.h[0]+h>>>0,this.h[1]=this.h[1]+r>>>0,this.h[2]=this.h[2]+i>>>0,this.h[3]=this.h[3]+s>>>0,this.h[4]=this.h[4]+l>>>0,this.h[5]=this.h[5]+n>>>0,this.h[6]=this.h[6]+o>>>0,this.h[7]=this.h[7]+f>>>0,this.h[8]=this.h[8]+a>>>0,this.h[9]=this.h[9]+u>>>0,this.h[10]=this.h[10]+g>>>0,this.h[11]=this.h[11]+_>>>0,this.h[12]=this.h[12]+y>>>0,this.h[13]=this.h[13]+p>>>0,this.h[14]=this.h[14]+d>>>0,this.h[15]=this.h[15]+c>>>0}hash(t){if(!t||"string"!=typeof t)throw new Error("AetherHash: Input must be a non-empty string");this._initHashValues();let e=this._pad(t);for(let t=0;t<e.length;t+=64)this._compress(e.slice(t,t+64));let h="";for(let t=0;t<16;t++)h+=this.h[t].toString(16).padStart(8,"0");return h.toLowerCase()}hash256(t){return this.hash(t).substring(0,64)}hash512(t){return this.hash(t)}hmac(t,e){let h=128,r=(new TextEncoder).encode(t);r.length>h&&(r=(new TextEncoder).encode(this.hash(t)));let i=new Uint8Array(h),s=new Uint8Array(h);for(let t=0;t<h;t++)i[t]=54,s[t]=92;for(let t=0;t<r.length;t++)i[t]^=r[t],s[t]^=r[t];let l=Array.from(i).map(t=>t.toString(16).padStart(2,"0")).join(""),n=Array.from(s).map(t=>t.toString(16).padStart(2,"0")).join(""),o=this.hash(l+this._strToHex(e));return this.hash(n+o)}_strToHex(t){return Array.from((new TextEncoder).encode(t)).map(t=>t.toString(16).padStart(2,"0")).join("")}}class AetherCipher{constructor(t){if(!t||"string"!=typeof t)throw new Error("AetherCipher: Key must be a non-empty string");this.blockSize=16,this.halfSize=8,this.rounds=32,this.masterKey=this._hashTo256(t),this.hasher=new AetherHash,this._initKeySchedule()}_irreduciblePolys(){return[283,285,299,301,313,319,333,351,355,357,361,369,375,379,391,395,397,415,419,425,433,445,451,463,471,477,487,499,501,505]}_hashTo256(t){const e=String(t);let h=new Uint32Array(8);h[0]=1779033703,h[1]=3144134277,h[2]=1013904242,h[3]=2773480762,h[4]=1359893119,h[5]=2600822924,h[6]=528734635,h[7]=1541459225;for(let t=0;t<e.length;t++){let r=e.charCodeAt(t);for(let t=0;t<8;t++)h[t]^=r<<3*t|r>>>5-t,h[t]=2654435769*h[t]>>>0,h[t]^=h[t+3&7]^h[t+7&7]}let r=new Uint8Array(32);for(let t=0;t<8;t++)r[4*t]=h[t]>>24&255,r[4*t+1]=h[t]>>16&255,r[4*t+2]=h[t]>>8&255,r[4*t+3]=255&h[t];for(let t=0;t<100;t++){for(let t=0;t<8;t++)h[t]=2654435769*h[t]>>>0^h[t+3&7];let t=new Uint8Array(32);for(let e=0;e<8;e++)t[4*e]=h[e]>>24&255,t[4*e+1]=h[e]>>16&255,t[4*e+2]=h[e]>>8&255,t[4*e+3]=255&h[e];for(let e=0;e<32;e++)r[e]^=t[e]}return r}_initKeySchedule(){let t=0;for(let e=0;e<32;e++)t^=this.masterKey[e]<<e%4*8,t=2654435769*t>>>0;let e=t,h=2654435769^t,r=2246822507^t,i=3266489909^t;const s=()=>{let t=e^e<<11;return e=h,h=r,r=i,i=i^i>>>19^t^t>>>8,i>>>0};let l=new Uint8Array(this.rounds*this.halfSize);for(let t=0;t<l.length;t++)l[t]=255&s(),l[t]^=this.masterKey[t%32],l[t]^=31*t&255;for(let t=0;t<3;t++)for(let e=0;e<32;e++){let h=(e+7*t)%l.length;l[h]^=this._rotl(this.masterKey[e],3*t),l[l.length-1-h]^=this._rotr(this.masterKey[e],5*t)}this.roundKeys=[];for(let t=0;t<this.rounds;t++)this.roundKeys.push(l.slice(t*this.halfSize,(t+1)*this.halfSize));this.sboxes=[];for(let t=0;t<16;t++){let e=0;for(let h=0;h<8;h++)e^=this.masterKey[(8*t+h)%32]<<4*h,e=2654435769*e>>>0;let h=this._generatePerfectSBox(e,t),r=new Array(256).fill(!1);for(let e=0;e<256;e++){if(r[h[e]]){console.error(`CRITICAL: S-box ${t} invalid!`);break}r[h[e]]=!0}this.sboxes.push(h)}this.invSboxes=[];for(let t=0;t<16;t++){let e=new Uint8Array(256);for(let h=0;h<256;h++)e[this.sboxes[t][h]]=h;this.invSboxes.push(e)}}_gf256Log(t,e,h){return e[t]}_gf256Exp(t,e,h){return h[255&t]}_generateLogExpTables(t){let e=new Uint8Array(256),h=new Uint8Array(512),r=1;for(let i=0;i<255;i++)h[i]=r,e[r]=i,r=this._gf256Mult(r,2,t);for(let t=255;t<512;t++)h[t]=h[t-255];return{log:e,exp:h}}_gf256MultFast(t,e,h,r){return 0===t||0===e?0:r[h[t]+h[e]]}_gf256InvFast(t,e,h){return 0===t?0:h[255-e[t]]}_calculateNonlinearity(t){let e=0;for(let h=1;h<256;h++){let r=0;for(let e=0;e<256;e++)r+=this._popcount(e&h)%2==this._popcount(1&t[e])%2?1:-1;let i=Math.abs(r);i>e&&(e=i)}return 128-e/2}_generatePerfectSBox(t,e){let h=this._irreduciblePolys(),r=h[((t>>>24)+13*e)%h.length],i=new Uint8Array(256);for(let t=0;t<256;t++)i[t]=this._gf256Inv(t,r);let s=t>>>e%4*8&255;for(let t=0;t<256;t++)i[t]^=s;let l=t>>>e%8&7;if(0!==l)for(let t=0;t<256;t++)i[t]=255&(i[t]<<l|i[t]>>8-l);let n=60*e&255;for(let t=0;t<256;t++)i[t]^=n;let o=!0;for(let t=0;t<256;t++)if(i[i[t]]!==t){o=!1;break}if(o){let e=t>>>24&255;for(let t=0;t<256;t++)i[t]^=e;let h=!0;for(let t=0;t<256;t++)if(i[i[t]]!==t){h=!1;break}if(h){let e=1+(t>>>16&3);for(let t=0;t<256;t++)i[t]=255&(i[t]<<e|i[t]>>8-e)}}return i}_rotl(t,e){return t<<e|t>>>32-e}_rotr(t,e){return t>>>e|t<<32-e}_popcount(t){return t=(t=(858993459&(t-=t>>1&1431655765))+(t>>2&858993459))+(t>>4)&252645135,63&(t+=t>>8)+(t>>16)}_gf256Mult(t,e,h){let r=0;for(;t&&e;)1&e&&(r^=t),e>>=1,256&(t<<=1)&&(t^=h);return 255&r}_gf256Pow(t,e,h){let r=1,i=t;for(;e>0;)1&e&&(r=this._gf256Mult(r,i,h)),i=this._gf256Mult(i,i,h),e>>=1;return r}_gf256Inv(t,e){return 0===t?0:this._gf256Pow(t,254,e)}_towerFieldInvert(t,e,h){let r=t>>4,i=15&t,s=this._generate4bitMatrix(e),l=0,n=0;for(let t=0;t<4;t++)r>>t&1&&(l^=s[t]),i>>t&1&&(n^=s[t+4]);let o=this._gf16Mult(l,l,h),f=this._gf16Mult(l,n,h),a=this._gf16Mult(n,n,h),u=this._gf16Add(o,this._gf16Add(f,this._gf16Mult(a,9,h)),h),g=this._gf16Inv(u,h),_=this._gf16Mult(this._gf16Add(l,n,h),g,h)<<4|this._gf16Mult(n,g,h);return this._applyAffine(_,this._generateAffineMatrix(e^h),e>>4&255)}_gf16Add(t,e,h){return t^e}_gf16Mult(t,e,h){let r=0;for(;t&&e;)1&e&&(r^=t),e>>=1,16&(t<<=1)&&(t^=h);return 15&r}_gf16Inv(t,e){if(0===t)return 0;let h=1;for(let r=0;r<14;r++)h=this._gf16Mult(h,t,e);return h}_generate4bitMatrix(t){let e=[8,4,2,1],h=t,r=40503^t;for(let t=0;t<16;t++){h^=h<<3,h^=h>>>5,h^=h<<7,r^=r<<5,r^=r>>>3,r^=r<<9;let t=h+r&3,i=h+r+1&3;t!==i&&(e[t]^=e[i])}return e}_dynamicFeistelRound(t,e,h){let r=t>>4,i=15&t,s=this._gf16Mult(i,15&e,19);return s=this._gf16Add(s,15&h,19),s=s<<1|s>>3,(i^s)<<4|r^this._gf16Mult(s,e>>4&15,19)}_applyMDS(t,e,h,r){let i=new Uint8Array(8);return r?(i[0]=this._gf256Mult(t[0],2,h)^this._gf256Mult(t[1],3,h)^t[2]^t[3],i[1]=t[0]^this._gf256Mult(t[1],2,h)^this._gf256Mult(t[2],3,h)^t[3],i[2]=t[0]^t[1]^this._gf256Mult(t[2],2,h)^this._gf256Mult(t[3],3,h),i[3]=this._gf256Mult(t[0],3,h)^t[1]^t[2]^this._gf256Mult(t[3],2,h),i[4]=this._gf256Mult(t[4],2,h)^this._gf256Mult(t[5],3,h)^t[6]^t[7],i[5]=t[4]^this._gf256Mult(t[5],2,h)^this._gf256Mult(t[6],3,h)^t[7],i[6]=t[4]^t[5]^this._gf256Mult(t[6],2,h)^this._gf256Mult(t[7],3,h),i[7]=this._gf256Mult(t[4],3,h)^t[5]^t[6]^this._gf256Mult(t[7],2,h)):(i[0]=this._gf256Mult(t[0],14,h)^this._gf256Mult(t[1],11,h)^this._gf256Mult(t[2],13,h)^this._gf256Mult(t[3],9,h),i[1]=this._gf256Mult(t[0],9,h)^this._gf256Mult(t[1],14,h)^this._gf256Mult(t[2],11,h)^this._gf256Mult(t[3],13,h),i[2]=this._gf256Mult(t[0],13,h)^this._gf256Mult(t[1],9,h)^this._gf256Mult(t[2],14,h)^this._gf256Mult(t[3],11,h),i[3]=this._gf256Mult(t[0],11,h)^this._gf256Mult(t[1],13,h)^this._gf256Mult(t[2],9,h)^this._gf256Mult(t[3],14,h),i[4]=this._gf256Mult(t[4],14,h)^this._gf256Mult(t[5],11,h)^this._gf256Mult(t[6],13,h)^this._gf256Mult(t[7],9,h),i[5]=this._gf256Mult(t[4],9,h)^this._gf256Mult(t[5],14,h)^this._gf256Mult(t[6],11,h)^this._gf256Mult(t[7],13,h),i[6]=this._gf256Mult(t[4],13,h)^this._gf256Mult(t[5],9,h)^this._gf256Mult(t[6],14,h)^this._gf256Mult(t[7],11,h),i[7]=this._gf256Mult(t[4],11,h)^this._gf256Mult(t[5],13,h)^this._gf256Mult(t[6],9,h)^this._gf256Mult(t[7],14,h)),i}_generateAffineMatrix(t){let e=t,h=2654435769^t,r=2246822507^t;const i=()=>(e^=e<<13,e^=e>>>17,e^=e<<5,h^=h<<3,h^=h>>>19,h^=h<<7,r^=r<<11,r^=r>>>13,r^=r<<17,e+h+r>>>0);let s=[1,2,4,8,16,32,64,128];for(let t=0;t<32;t++){let t=i()%8,e=i()%8;t!==e&&(s[t]^=s[e])}for(let t=7;t>0;t--){let e=i()%(t+1);[s[t],s[e]]=[s[e],s[t]]}return s}_gf256MatrixDet(t){let e=t.slice(),h=0;for(let t=0;t<8;t++){let r=-1;for(let i=h;i<8;i++)if(e[i]>>t&1){r=i;break}if(-1!==r){[e[h],e[r]]=[e[r],e[h]];for(let r=h+1;r<8;r++)e[r]>>t&1&&(e[r]^=e[h]);h++}}return 8===h?1:0}_applyAffine(t,e,h){let r=0;for(let h=0;h<8;h++)t>>h&1&&(r^=e[h]);return r^h}_makePermutation(t){let e=new Array(256).fill(!1);for(let h=0;h<256;h++){if(e[t[h]])for(let r=0;r<256;r++)if(!e[r]){t[h]=r;break}e[t[h]]=!0}let h=0;for(let e=1;e<256;e++){let r=new Array(256).fill(0);for(let h=0;h<256;h++)r[t[h]^t[h^e]]++;let i=Math.max(...r);i>h&&(h=i)}}_chaoticRng(t){return function(){return(16777215&(t=1664525*t+1013904223>>>0))/16777216}}_F(t,e){let h=new Uint8Array(t);for(let t=0;t<8;t++)h[t]^=this.roundKeys[e][t];for(let t=0;t<8;t++){let r=(t+3*e)%16;h[t]=this.sboxes[r][h[t]]}let r=this._getRoundPoly(e),i=this._applyMDS(h,e,r,!0);for(let t=0;t<8;t++)i[t]^=e+27*t&255;return i}_getRoundPoly(t){const e=[283,285,299,301,313,319,333,351,355,357,361,369,375,379,391,395,397,415,419,425,433,445,451,463,471,477,487,499,501,505];let h=t;for(let e=0;e<4;e++)h^=this.masterKey[(4*t+e)%32];return e[h%e.length]}encryptBlock(t){let e=new Uint8Array(t);for(let t=0;t<this.rounds;t++){for(let h=0;h<16;h++){let r=(h+3*t)%16;e[h]=this.sboxes[r][e[h]^this.roundKeys[t][h%8]]}let h=this._getRoundPoly(t),r=this._applyMDS(e.slice(0,8),t,h,!0),i=this._applyMDS(e.slice(8,16),t,h,!0),s=new Uint8Array(16);s.set(r,0),s.set(i,8);let l=new Uint8Array(16);for(let t=0;t<16;t++)l[t]=s[(t+1)%16];for(let e=0;e<16;e++)l[e]^=27*t+60*e&255;e=l}return e}decryptBlock(t){let e=new Uint8Array(t);for(let t=this.rounds-1;t>=0;t--){for(let h=0;h<16;h++)e[h]^=27*t+60*h&255;let h=new Uint8Array(16);for(let t=0;t<16;t++)h[(t+1)%16]=e[t];let r=h.slice(0,8),i=h.slice(8,16),s=this._getRoundPoly(t),l=this._applyMDS(r,t,s,!1),n=this._applyMDS(i,t,s,!1);for(let h=0;h<8;h++){let r=(h+3*t)%16,i=(h+8+3*t)%16;e[h]=this.invSboxes[r][l[h]]^this.roundKeys[t][h%8],e[h+8]=this.invSboxes[i][n[h]]^this.roundKeys[t][(h+8)%8]}}return e}_pad(t){let e=this.blockSize-t.length%this.blockSize,h=new Uint8Array(t.length+e);h.set(t);for(let r=t.length;r<h.length;r++)h[r]=e;return h}_unpad(t){let e=t[t.length-1];if(e<1||e>this.blockSize)throw new Error("AetherCipher: Invalid padding - wrong key or corrupted data");return t.slice(0,t.length-e)}_generateIv(){this._ivCounter||(this._ivKey=this.hasher.hash256(this._bytesToHex(this.masterKey)+"AETHER_IV_SEED"),this._ivCounter=0n);let t=this._ivCounter.toString(16).padStart(32,"0"),e=this._ivKey+t,h=this.hasher.hash256(e).substring(0,32);return this._ivCounter++,this._hexToBytes(h)}_authTag(t,e){let h=this.hasher.hash256(this._bytesToHex(t)+e);return this._hexToBytes(h).slice(0,8)}encrypt(t){if(!t||"string"!=typeof t)throw new Error("AetherCipher: Plaintext must be a non-empty string");let e=(new TextEncoder).encode(t),h=this._pad(e),r=this._generateIv(),i=[],s=r;for(let t=0;t<h.length;t+=16){let e=h.slice(t,t+16);for(let t=0;t<16;t++)e[t]^=s[t];let r=this.encryptBlock(e);i.push(r),s=r}let l=new Uint8Array(r.length+h.length);l.set(r);let n=r.length;for(let t of i)l.set(t,n),n+=16;let o=this._bytesToHex(l);return o+this.hasher.hash256(o+this._bytesToHex(this.masterKey)).substring(0,16)}decrypt(t){if(!t||"string"!=typeof t)throw new Error("AetherCipher: Ciphertext must be a hex string");let e=this._hexToBytes(t);if(e.length<32)throw new Error("AetherCipher: Ciphertext too short");let h=this._bytesToHex(e.slice(0,e.length-8)),r=this._bytesToHex(e.slice(e.length-8));if(this.hasher.hash256(h+this._bytesToHex(this.masterKey)).substring(0,16)!==r)throw new Error("AetherCipher: Authentication failed - wrong key or corrupted data");let i=e.slice(0,16),s=e.slice(16,e.length-8),l=[];for(let t=0;t<s.length;t+=16)l.push(s.slice(t,t+16));let n=[],o=i;for(let t of l){let e=this.decryptBlock(t);for(let t=0;t<16;t++)e[t]^=o[t];n.push(e),o=t}let f=new Uint8Array(16*n.length),a=0;for(let t of n)f.set(t,a),a+=16;let u=this._unpad(f);return(new TextDecoder).decode(u)}_bytesToHex(t){return Array.from(t).map(t=>t.toString(16).padStart(2,"0")).join("")}_hexToBytes(t){if(!/^[0-9a-fA-F]+$/.test(t))throw new Error("AetherCipher: Invalid hex string");let e=new Uint8Array(t.length/2);for(let h=0;h<t.length;h+=2)e[h/2]=parseInt(t.substr(h,2),16);return e}testVectors(){const t=[{key:"key1",plain:"Hello World!"},{key:"ðŸŒŸðŸ”¥",plain:"Creative unicode âœ“"},{key:"longkey".repeat(10),plain:"A".repeat(300)}];let e=[];for(let h of t){let t=new AetherCipher(h.key),r=t.encrypt(h.plain),i=t.decrypt(r)===h.plain;e.push({key:h.key.substring(0,10)+"â€¦",plain:h.plain.substring(0,20)+"â€¦",pass:i})}return e}avalancheTest(){let t=0,e=[];for(let h=0;h<20;h++){const h=Math.random().toString(36).substring(2)+Math.random().toString(36).substring(2);let r=Math.floor(Math.random()*h.length),i=h.substring(0,r)+String.fromCharCode(1^h.charCodeAt(r))+h.substring(r+1),s=this.encrypt(h),l=this.encrypt(i),n=this._hexToBytes(s),o=this._hexToBytes(l),f=0;for(let t=0;t<n.length;t++){let e=n[t]^o[t];for(;e;)f+=1&e,e>>=1}let a=f/(8*n.length)*100;e.push(a),t+=a}let h=t/20,r=Math.min(...e),i=Math.max(...e);return console.log(`avalanche: avg=${h.toFixed(2)}% min=${r.toFixed(2)}% max=${i.toFixed(2)}%`),h}}"undefined"!=typeof window&&(window.AetherCipher=AetherCipher,window.AetherHash=AetherHash),"undefined"!=typeof module&&module.exports&&(module.exports={AetherCipher:AetherCipher,AetherHash:AetherHash});
