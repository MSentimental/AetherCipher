/*!
 * AetherWarp
 * 
 * [AetherWarp - Public]{@link https://cdn.jsdelivr.net/gh/msentimental/AetherCipher@latest/build/aetherwarp.min.js}
 *
 * @version 1.0.0
 * @author msentimental [lijinhan2025@gmail.com]
 * @copyright Strike Bot Inc. 2026
 * @license See full license at https://github.com/MSentimental/AetherCipher/blob/main/LICENSE.md
 * 
 * Includes:
 *   - AetherWarp: An extremely lightweight, faster version of AetherHash for one-way hashing
 * 
 * [Usage examples]:
 *
 * <script>
 *   // initialize aetherWarp
 *   const warp = new AetherWarp();
 *   
 *   // hashing
 *   const warpHash = warp.hash256('Hello World!');
 *   console.log('Hash:', warpHash);
 *   
 *   // Benchmark
 *   AetherWarp.benchmark();
 * </script>
 */

class t{constructor(){this.k=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221]),this.iv=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),this.s=new Uint32Array(16)}_rotl(t,r){return t<<r|t>>>32-r}hash(t){if(!t||"string"!=typeof t)throw new Error("AetherWarp: Input must be a non-empty string");const r=(new TextEncoder).encode(t),s=r.length,h=8+(s+9+64-1&-64),i=new Uint8Array(h);for(let t=0;t<s;t++)i[t]=r[t];i[s]=128;const o=8*s;for(let t=0;t<8;t++)i[h-8+t]=o>>>8*t&255;const e=new Uint32Array(i.buffer),l=this.s;for(let t=0;t<8;t++)l[t]=this.iv[t],l[t+8]=0;for(let t=0;t<e.length;t+=16){for(let r=0;r<16;r++)l[r]^=e[t+r];let r=l[0],s=l[1],h=l[2],i=l[3],o=l[4],n=l[5],_=l[6],a=l[7],c=l[8],f=l[9],k=l[10],w=l[11],d=l[12],u=l[13],p=l[14],y=l[15],A=r+o+this.k[0]>>>0;d^=A,d=this._rotl(d,16),c=c+d>>>0,o^=c,o=this._rotl(o,12),A=s+n+this.k[0]>>>0,u^=A,u=this._rotl(u,16),f=f+u>>>0,n^=f,n=this._rotl(n,12),A=h+_+this.k[0]>>>0,p^=A,p=this._rotl(p,16),k=k+p>>>0,_^=k,_=this._rotl(_,12),A=i+a+this.k[0]>>>0,y^=A,y=this._rotl(y,16),w=w+y>>>0,a^=w,a=this._rotl(a,12),A=r+n+this.k[1]>>>0,y^=A,y=this._rotl(y,8),k=k+y>>>0,n^=k,n=this._rotl(n,7),A=s+_+this.k[1]>>>0,d^=A,d=this._rotl(d,8),w=w+d>>>0,_^=w,_=this._rotl(_,7),A=h+a+this.k[1]>>>0,u^=A,u=this._rotl(u,8),c=c+u>>>0,a^=c,a=this._rotl(a,7),A=i+o+this.k[1]>>>0,p^=A,p=this._rotl(p,8),f=f+p>>>0,o^=f,o=this._rotl(o,7),A=r+o+this.k[2]>>>0,d^=A,d=this._rotl(d,19),c=c+d>>>0,o^=c,o=this._rotl(o,23),A=s+n+this.k[2]>>>0,u^=A,u=this._rotl(u,19),f=f+u>>>0,n^=f,n=this._rotl(n,23),A=h+_+this.k[2]>>>0,p^=A,p=this._rotl(p,19),k=k+p>>>0,_^=k,_=this._rotl(_,23),A=i+a+this.k[2]>>>0,y^=A,y=this._rotl(y,19),w=w+y>>>0,a^=w,a=this._rotl(a,23),A=r+n+this.k[3]>>>0,y^=A,y=this._rotl(y,11),k=k+y>>>0,n^=k,n=this._rotl(n,9),A=s+_+this.k[3]>>>0,d^=A,d=this._rotl(d,11),w=w+d>>>0,_^=w,_=this._rotl(_,9),A=h+a+this.k[3]>>>0,u^=A,u=this._rotl(u,11),c=c+u>>>0,a^=c,a=this._rotl(a,9),A=i+o+this.k[3]>>>0,p^=A,p=this._rotl(p,11),f=f+p>>>0,o^=f,o=this._rotl(o,9),l[0]=r,l[1]=s,l[2]=h,l[3]=i,l[4]=o,l[5]=n,l[6]=_,l[7]=a,l[8]=c,l[9]=f,l[10]=k,l[11]=w,l[12]=d,l[13]=u,l[14]=p,l[15]=y}let n="";for(let t=0;t<8;t++){let r=l[t];n+=String.fromCharCode(r>>>24&255,r>>>16&255,r>>>8&255,255&r)}const _="0123456789abcdef";let a="";for(let t=0;t<32;t++)a+=_[n.charCodeAt(t)>>>4&15]+_[15&n.charCodeAt(t)];return a}hash256(t){return this.hash(t).substring(0,64)}hash512(t){return this.hash(t)}static async benchmark(r=52428800){const s=new t,h="x".repeat(r);for(let t=0;t<5;t++)s.hash256("warmup");const i=performance.now(),o=(s.hash256(h),performance.now()-i),e=(r/o/1024).toFixed(2);return console.log(`${(r/1024/1024).toFixed(2)} MB in ${o.toFixed(2)} ms`),console.log(`${e} MB/s (${(e/1024).toFixed(2)} GB/s)`),e}}"undefined"!=typeof window&&(window.AetherWarp=t);
